# Лучшие практики

***

### Константы должны именоваться только заглавными буквами, с разделителем в виде подчеркивания.

***

##### Имена констант используют CONSTANT_CASE: все буквы прописные, слова разделяются символом подчеркивания.В этом правиле есть исключение: константа, ограниченная областью функции. В этом случае ее имя должно писаться в camelCase.

;)

    const NUMBER = 10;

:(

    const number = 10;

***

### Объявляем переменные по одной

##### Объявление каждой локальной переменной объявляет только одну переменную: такие объявления, как let a = 1, b = 2; не используются

;)

    let a = 1;
    let b = 2;
    let c = 3;

:(

    let a = 1, b = 2, c = 3;

***

### Как правильно переносить длинную строку в JS

;)

     const foo = (
      superLongLongLongLongLongLongLongLongFunctionName()
     );


     const foo = 'superLongLongLongLongLongLongLongLongString’;

:(

     const foo =
      superLongLongLongLongLongLongLongLongFunctionName();

    const foo
     = 'superLongLongLongLongLongLongLongLongString’;

***

### Условные выражения и равенства


#####  Используем === и !== вместо == и !=.
Условные выражения вычисляются посредством приведения к логическому типу Boolean через метод ToBoolean и всегда следуют следующим правилам:

+ Object всегда соответствует true
+ Undefined всегда соответствует false
+ Null всегда соответствует false
+ Boolean остается неизменным
+ Number соответствует false, если является +0, -0, или NaN, в противном случае соответствует true
+ String означает false, если является пустой строкой '', в противном случае true. Условно говоря, для строки происходит сравнение не ее самой, а ее длины – в соответствии с типом number.

      If ([0]) {
      // true
      // Массив(Array) является объектом, объекты преобразуются в true
      }

 ***

### THIS

***


+ Используем this только в конструкторах и методах класса, в стрелочных функциях, определенных внутри конструкторов и методов класса, или в функциях, которые имеют явный @this, объявленный в JSDoc, а также в функциях, которые сразу закрываются.

+ Никогда не используем this для обращения к глобальному объекту, контексту eval, target принадлежащему event, или ненужному call() или apply() функций.

***


### Не взаимодействуем напрямую с prototype

+ Ключевое слово class позволяет более четко и читаемо определить класс, чем определение свойств прототипа. Смешивать и модифицировать прототипы встроенных объектов явно — запрещено.

Исключения: Коду фреймворка (например, Polymer или Angular) может потребоваться использовать prototype, и не следует прибегать к обходным путям, чтобы избежать этого.

***

### Стиль блочных комментариев

***


Блочные комментарии снабжены отступом на том же уровне, что и окружающий код. Они могут быть в стиле /* … */ или //. Для многострочных комментариев /* … */ последующие строки должны начинаться с *, выровненного с * на предыдущей строке, чтобы комментарии были очевидны без лишнего контекста.

    /*
     * Это выглядит
     * хорошо.
     */

    // Тоже
    // хорошо.

    /* Аналогично */

***

### Используем пробелы, а не табы

Помимо перевода строки, горизонтальный символ пробела (0x20) ASCII это единственный пробельный символ, используемый в файле исходного кода. Это означает, что символы табуляции не используются для отступов. Для создания отступов следует использовать два пробела (не четыре).



;)

    function baz() {
    ∙∙let name;
    }

:(

    function foo() {
    ∙∙∙∙let name;
    }

    function bar() {
    ∙let name;
    }

***

### Getters и Setters

***

Не используем JavaScript getter и setter свойства. Они потенциально неочевидны и трудны в понимании, а также имеют ограниченную поддержку в компиляторе. Вместо этого предоставьте обычные методы.

Исключения: бывают ситуации, когда определение геттера или сеттера неизбежно (например, фреймворки с привязкой данных, такие как Angular и Polymer, или для совместимости с внешними API, который невозможно настроить). Только в этих случаях можно использовать геттеры и сеттеры с осторожностью и при условии, что они определены с помощью короткого вида записи метода get и set или Object.defineProperties (не Object.defineProperty, что мешает переименованию свойств). Геттеры не должны изменять видимое состояние.

***

### Лимит строки: 80 символов

***

Код JavaScript имеет ограничение столбца в 80 символов. За исключением некоторых случаев, любая строка, которая превысила бы этот предел, должна быть перенесена по определенным правилам.

Предпочтительно:

     currentEstimate =
       calc(currentEstimate + x * currentEstimate) /
         2.0;

##### Операторы переносятся следующим образом:

Когда у оператора разрывается строка, разрыв следует за оператором.
Имя метода или конструктора остается присоединенным к открытой круглой скобке ((), которая следует за ней.
Запятая (,) остается прикрепленной к символу, который предшествует ей.
Основной целью переноса строк является наличие понятного кода, а не обязательно кода, который помещается в наименьшее количество строк.
